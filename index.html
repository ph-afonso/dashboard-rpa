<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Automações (RPA)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Calm Harmony (Warm neutrals with soft blue/green accents) -->
    <!-- Application Structure Plan: A dashboard-style SPA. Key metrics and a status distribution doughnut chart at the top provide an instant overview. The main content is an interactive, filterable grid of cards, each representing a bot. Clicking a card opens a detailed modal view using a progressive disclosure pattern. This structure is chosen to transform the static list-based report into an explorable inventory, allowing users to quickly get a high-level summary and drill down into specifics without being overwhelmed. -->
    <!-- Visualization & Content Choices: 1. Bot Status Distribution -> Goal: Inform proportion -> Viz: Doughnut Chart -> Interaction: Updates on filter -> Justification: Ideal for part-to-whole data, provides quick visual summary of program health -> Library: Chart.js (Canvas). 2. Bot Catalog -> Goal: Organize/Explore -> Presentation: Card Grid -> Interaction: Filter by status, click for modal -> Justification: Scannable, organized, and uses progressive disclosure for details -> Library/Method: JS DOM Manipulation + Tailwind CSS. The separate summary table is integrated into the card/modal design for a more cohesive interactive experience. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f7f4;
            color: #3d3d3d;
        }
        .status-tag {
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .status-producao { background-color: #d1fae5; color: #065f46; }
        .status-testes { background-color: #feefc3; color: #92400e; }
        .status-desenvolvimento { background-color: #dbeafe; color: #1e40af; }
        .modal { transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; }
        .modal-content { transition: transform 0.3s ease-in-out; }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 350px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
    </style>
</head>
<body class="antialiased">

    <div class="min-h-screen p-4 sm:p-6 lg:p-8">
        <div class="max-w-7xl mx-auto">
            
            <header class="mb-8 flex items-center gap-4">
                <img src="https://www.tragetta.com.br/wp-content/uploads/2025/05/logotipo.png" alt="Logotipo Tragetta" class="h-12" onerror="this.style.display=''">
                <div>
                    <h1 class="text-3xl font-bold text-gray-800">Dashboard de Automações (RPA)</h1>
                    <p class="text-gray-500 mt-1">Visão geral dos processos automatizados, suas frequências e status.</p>
                </div>
            </header>

            <main>
                <section id="dashboard-overview" class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                    <div class="lg:col-span-2 bg-white p-6 rounded-2xl shadow-sm">
                        <h2 class="text-xl font-semibold text-gray-700 mb-4">Métricas Gerais</h2>
                        <div class="grid grid-cols-2 md:grid-cols-2 gap-4">
                            <div class="bg-gray-50 p-4 rounded-xl text-center">
                                <span class="text-3xl font-bold" id="total-bots">0</span>
                                <p class="text-sm font-medium text-gray-500 mt-1">Total de Robôs</p>
                            </div>
                            <div class="bg-gray-50 p-4 rounded-xl text-center">
                                <span class="text-3xl font-bold text-green-600" id="bots-producao">0</span>
                                <p class="text-sm font-medium text-gray-500 mt-1">Em Produção</p>
                            </div>
                            <div class="bg-gray-50 p-4 rounded-xl text-center">
                                <span class="text-3xl font-bold text-amber-600" id="bots-testes">0</span>
                                <p class="text-sm font-medium text-gray-500 mt-1">Em Testes</p>
                            </div>
                            <div class="bg-gray-50 p-4 rounded-xl text-center">
                                <span class="text-3xl font-bold text-blue-600" id="bots-desenvolvimento">0</span>
                                <p class="text-sm font-medium text-gray-500 mt-1">Em Desenvolvimento</p>
                            </div>
                        </div>
                         <p class="text-xs text-gray-400 mt-6">Este painel oferece uma visão geral do nosso ecossistema de automação. Use os filtros para explorar os robôs por categoria e clique em um card para visualizar seus detalhes.</p>
                    </div>
                    <div class="bg-white p-6 rounded-2xl shadow-sm flex flex-col justify-center">
                        <h2 class="text-xl font-semibold text-gray-700 mb-4 text-center">Distribuição por Status</h2>
                        <div class="chart-container">
                            <canvas id="statusChart"></canvas>
                        </div>
                    </div>
                </section>

                <section id="bot-catalog">
                    <div class="flex flex-wrap items-center justify-between gap-4 mb-6">
                        <h2 class="text-2xl font-semibold text-gray-700">Catálogo de Robôs</h2>
                        <div id="filters" class="flex flex-wrap items-center gap-4">
                            <div class="flex flex-wrap gap-2">
                                <button data-status="Todos" class="filter-btn-status bg-blue-600 text-white px-4 py-2 rounded-full text-sm font-semibold shadow">Todos</button>
                                <button data-status="Em Produção" class="filter-btn-status bg-white text-gray-700 px-4 py-2 rounded-full text-sm font-semibold shadow-sm hover:bg-gray-50">Em Produção</button>
                                <button data-status="Em Testes" class="filter-btn-status bg-white text-gray-700 px-4 py-2 rounded-full text-sm font-semibold shadow-sm hover:bg-gray-50">Em Testes</button>
                                <button data-status="Em Desenvolvimento" class="filter-btn-status bg-white text-gray-700 px-4 py-2 rounded-full text-sm font-semibold shadow-sm hover:bg-gray-50">Em Desenvolvimento</button>
                            </div>
                             <div class="flex items-center gap-2">
                                <label for="setor-filter" class="text-sm font-medium text-gray-600">Filtrar por Setor:</label>
                                <select id="setor-filter" class="bg-white text-gray-700 pl-3 pr-8 py-2 rounded-full text-sm font-semibold shadow-sm focus:ring-2 focus:ring-blue-500 focus:outline-none border-transparent appearance-none">
                                </select>
                            </div>
                            <button id="export-excel-btn" class="bg-green-600 text-white px-4 py-2 rounded-full text-sm font-semibold shadow-sm hover:bg-green-700 flex items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg>
                                Exportar para Excel
                            </button>
                        </div>
                    </div>
                    <div id="bot-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                    </div>
                </section>
            </main>
        </div>
    </div>

    <div id="modal" class="modal fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 opacity-0 pointer-events-none scale-95">
        <div class="modal-content bg-white w-full max-w-2xl max-h-[90vh] rounded-2xl shadow-2xl relative transform scale-100 overflow-y-auto">
            <button id="close-modal" class="absolute top-4 right-4 text-gray-400 hover:text-gray-700 transition">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
            <div class="p-8">
                <h2 id="modal-title" class="text-2xl font-bold text-gray-800 mb-1"></h2>
                <div id="modal-status-container" class="mb-6"></div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4 text-sm">
                    <div>
                        <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-1">Finalidade</h3>
                        <p id="modal-finalidade" class="text-gray-600"></p>
                    </div>
                     <div>
                        <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-1">Linguagem / Ferramenta</h3>
                        <p id="modal-ferramenta" class="text-gray-600"></p>
                    </div>
                     <div>
                        <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-1">Sistemas Integrados</h3>
                        <p id="modal-sistemas" class="text-gray-600"></p>
                    </div>
                     <div>
                        <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-1">Frequência de Execução</h3>
                        <p id="modal-frequencia" class="text-gray-600"></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-1">Setor</h3>
                        <p id="modal-setor" class="text-gray-600"></p>
                    </div>
                    <div class="md:col-span-2">
                        <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-1">Input (Entrada)</h3>
                        <p id="modal-input" class="text-gray-600 bg-gray-50 p-3 rounded-lg"></p>
                    </div>
                    <div class="md:col-span-2">
                        <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-1">Output (Saída)</h3>
                        <p id="modal-output" class="text-gray-600 bg-gray-50 p-3 rounded-lg"></p>
                    </div>
                     <div class="md:col-span-2">
                        <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-1">Funcionamento (Resumo)</h3>
                        <p id="modal-funcionamento" class="text-gray-600"></p>
                    </div>
                    <div class="md:col-span-2">
                        <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-1">Observações / Gaps</h3>
                        <p id="modal-gaps" class="text-gray-600"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const botData = [
                {
                    nome: 'Conemb_NFSE_Alpargatas',
                    finalidade: 'Gerar arquivos de Conhecimento de Embarque (CONEMB) a partir de planilhas de Notas Fiscais de Serviço (NFSe).',
                    sistemas: 'Pastas de rede (Sistema de Arquivos).',
                    input: 'Planilhas Excel (.xlsx) com os dados das notas fiscais.',
                    output: 'Arquivos de texto (.txt) formatados e logs de erro.',
                    funcionamento: 'O robô lê as planilhas, valida os dados, formata as informações no layout padrão do CONEMB e gera os arquivos de saída. Adicionalmente, cria alertas para notas fiscais que apresentem inconsistências.',
                    ferramenta: 'Python (com Pandas).',
                    frequencia: 'A cada 10 minutos.',
                    status: 'Em Produção',
                    setor: 'Administração Comercial',
                    gaps: 'Processo em fase de migração para o sistema TMS.'
                },
                {
                    nome: 'Recalculo_Planilhas_Agrupa',
                    finalidade: 'Recalcular fretes de Conhecimentos de Transporte (CT-e) com base em planilhas, agrupando informações e atualizando os valores diretamente nos arquivos de origem.',
                    sistemas: 'Banco de dados SQL Server (Newsitex), Pastas de rede.',
                    input: 'Planilhas Excel (.xlsx) com dados de CT-es para recálculo.',
                    output: 'Planilha Excel atualizada com os valores recalculados e observações.',
                    funcionamento: 'O robô lê as planilhas de entrada, conecta-se ao banco de dados SQL Server para executar as *procedures* (rotinas) de recálculo de frete e, por fim, atualiza os arquivos Excel originais com os novos valores e observações.',
                    ferramenta: 'Python (com Pandas e pyodbc).',
                    frequencia: 'A cada 5 minutos.',
                    status: 'Em Produção',
                    setor: 'Administração Comercial',
                    gaps: 'Processo em fase de migração para o sistema TMS.'
                },
                {
                    nome: 'Upload de Agendas',
                    finalidade: 'Automatizar a criação em massa de ocorrências de agendamento (tipos 140 e 91) a partir de uma tabela enviada por e-mail.',
                    sistemas: 'Banco de Dados SQL Server (Newsitex), Caixa de e-mail.',
                    input: 'E-mail enviado para rpacustserv@tragetta.com.br, com o assunto "Upload de Agenda" e contendo uma tabela com estrutura pré-definida no corpo da mensagem.',
                    output: 'E-mail de confirmação com o status dos agendamentos e o registro das ocorrências correspondentes no sistema TMS.',
                    funcionamento: 'O robô monitora a caixa de e-mail especificada. Ao receber um e-mail que corresponde ao padrão (assunto e tabela), extrai os dados, consulta o banco de dados do New Sitex e cria as ocorrências de agendamento (140 e 91) para cada item da lista.',
                    ferramenta: 'Python (com Pandas, pyodbc, BeautifulSoup), API Microsoft Graph.',
                    frequencia: 'A cada 2 minutos.',
                    status: 'Em Produção',
                    setor: 'Customer Service',
                    gaps: ''
                },
                {
                    nome: 'Confirmação de Solicitação DPA',
                    finalidade: 'Interpretar as respostas de e-mail dos clientes para identificar a sua intenção (confirmar, reagendar, etc.) e agendar automaticamente as solicitações do processo DPA.',
                    sistemas: 'Banco de dados SQL Server (Newsitex), Caixa de e-mail.',
                    input: 'E-mail com resposta à solicitação de agendamento DPA.',
                    output: 'Envio de e-mail com o status dos agendamentos para os responsáveis (focais) e criação das ocorrências no sistema.',
                    funcionamento: 'O robô monitora uma caixa de e-mails e, ao identificar uma resposta a uma solicitação do DPA, processa e classifica a intenção da mensagem para realizar o agendamento automático das ocorrências correspondentes.',
                    ferramenta: 'Python (com Pandas, pyodbc), API Microsoft Graph, Hugging Face.',
                    frequencia: 'A cada 1 minuto.',
                    status: 'Em Produção',
                    setor: 'Customer Service',
                    gaps: 'A precisão da automação depende da criação e teste contínuo de hipóteses para classificar a intenção nos textos. Como alternativa, sugere-se o desenvolvimento de um portal de confirmação (INIT 5399) para uma interação mais estruturada.'
                },
                {
                    nome: 'Solicitação de Agendamento RAIA',
                    finalidade: 'Automatizar a criação de *vouchers* de agendamento no portal do cliente (RAIA) e registrar a ocorrência 140 no banco de dados.',
                    sistemas: 'Banco de Dados SQL Server (Newsitex), Caixa de e-mail, Portal de Agendamento RAIA (Web).',
                    input: 'Dados inseridos por um usuário numa interface gráfica, incluindo CT-es, data, horário e informações de paletização.',
                    output: 'Envio de e-mail de confirmação com os comprovantes do agendamento (*vouchers*) para o usuário e/ou envio de arquivos XML para o cliente.',
                    funcionamento: 'Através de uma interface gráfica que exibe os CT-es do cliente, o usuário seleciona os documentos, define a data, o horário e a paletização. A automação utiliza o Selenium para acessar o portal do cliente e criar o *voucher* de agendamento com base nos dados fornecidos.',
                    ferramenta: 'Python (com Pandas, pyodbc), API Microsoft Graph, Selenium',
                    frequencia: 'A cada 2 minutos.',
                    status: 'Em Produção',
                    setor: 'Customer Service',
                    gaps: 'O acompanhamento dos processos em andamento é um desafio. A automação via Selenium está suscetível a falhas devido à instabilidade da interface do portal. A solução ideal seria uma integração via API, que não foi disponibilizada pelo cliente.'
                },
                {
                    nome: 'Solicitação de Agendamento EPM',
                    finalidade: 'Automatizar a criação de agendamentos no portal do cliente (EPM) e registrar as ocorrências de agendamento (140 e 91) no banco de dados.',
                    sistemas: 'Banco de Dados SQL Server (Newsitex), Caixa de e-mail, Portal de Agendamento EPM (Web).',
                    input: 'Dados inseridos por um usuário numa interface gráfica, incluindo CT-es, data, horário e informações de paletização.',
                    output: 'Envio de e-mail de confirmação com os comprovantes do agendamento.',
                    funcionamento: 'Através de uma interface gráfica que exibe os CT-es do cliente, o usuário seleciona os documentos e define os detalhes do agendamento. A automação utiliza o Selenium para acessar o portal do cliente e criar o agendamento com base nos dados fornecidos.',
                    ferramenta: 'Python (com Pandas, pyodbc), API Microsoft Graph, Selenium',
                    frequencia: 'A cada 5 minutos.',
                    status: 'Em Produção',
                    setor: 'Customer Service',
                    gaps: 'O acompanhamento dos processos em andamento é um desafio. A automação via Selenium está suscetível a falhas devido à instabilidade da interface do portal. A solução ideal seria uma integração via API, que não foi disponibilizada pelo cliente.'
                },
                {
                    nome: 'Solicitação de Agendamento PROFARMA',
                    finalidade: 'Automatizar a criação de agendamentos no portal do cliente (PROFARMA) e registrar as ocorrências de agendamento (140 e 91) no banco de dados.',
                    sistemas: 'Banco de Dados SQL Server (Newsitex), Caixa de e-mail, Portal de Agendamento PROFARMA (Web).',
                    input: 'Dados inseridos por um usuário numa interface gráfica, incluindo CT-es, data, horário e informações de paletização.',
                    output: 'Envio de e-mail de confirmação com os comprovantes do agendamento.',
                    funcionamento: 'Através de uma interface gráfica que exibe os CT-es do cliente, o usuário seleciona os documentos e define os detalhes do agendamento. A automação utiliza o Selenium para acessar o portal do cliente e criar o agendamento com base nos dados fornecidos.',
                    ferramenta: 'Python (com Pandas, pyodbc), API Microsoft Graph, Selenium',
                    frequencia: 'A cada 5 minutos.',
                    status: 'Em Desenvolvimento',
                    setor: 'Customer Service',
                    gaps: 'O acompanhamento dos processos em andamento é um desafio. A automação via Selenium está suscetível a falhas devido à instabilidade da interface do portal. A solução ideal seria uma integração via API, que não foi disponibilizada pelo cliente.'
                },
                {
                    nome: 'Alteração de Vencimento',
                    finalidade: 'Atualizar em massa as datas de vencimento de faturas no sistema Oracle Cloud.',
                    sistemas: 'Oracle Cloud (via API REST), Pastas de rede.',
                    input: 'Planilha Excel (.xlsx) com IDs de fatura e a nova data de vencimento.',
                    output: 'Faturas atualizadas no Oracle Cloud e log de processamento na consola. O arquivo de entrada é movido para uma pasta de processados.',
                    funcionamento: 'O robô lê as planilhas de uma pasta específica, extrai os IDs das faturas e a nova data de vencimento. Para cada fatura, conecta-se à API do Oracle Cloud, obtém um link de alteração específico e envia a nova data, efetivando a mudança no sistema.',
                    ferramenta: 'Python (com Pandas, Requests).',
                    frequencia: 'De hora em hora.',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                {
                    nome: 'App Agregados',
                    finalidade: 'Realizar o lançamento de avisos de débito (descontos por processos jurídicos) para fornecedores no Oracle Cloud, através de uma aplicação de desktop.',
                    sistemas: 'Oracle Cloud (API REST), Aplicação de Desktop (GUI), Servidor de E-mail (SMTP), Pastas de rede.',
                    input: 'Dados inseridos pelo usuário numa interface gráfica (Tkinter), incluindo CNPJ/CPF do fornecedor, valor, filial, tipo de processo e arquivos de anexo.',
                    output: 'Criação de uma fatura do tipo "Aviso de débito" validada no Oracle Cloud, envio de e-mail de notificação com anexos e atualização de uma planilha de histórico.',
                    funcionamento: 'O usuário preenche os dados numa aplicação que se conecta à API da Oracle para criar uma fatura de débito. O processo inclui o upload de anexos, a validação da fatura no sistema e o envio de um e-mail de confirmação para as partes interessadas.',
                    ferramenta: 'Python (com Tkinter, Requests, Pandas, SMTPLib).',
                    frequencia: 'Sob demanda',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: 'Processo em fase de migração para o sistema TMS.'
                },
                {
                    nome: 'App Arredondamento',
                    finalidade: 'Ajustar e recalcular valores em arquivos de Conhecimento de Embarque (CONEMB) através de uma aplicação de desktop.',
                    sistemas: 'Aplicação de Desktop (GUI), Pastas de rede (Sistema de Arquivos).',
                    input: 'Arquivo de texto (.txt) do tipo CONEMB selecionado pelo usuário através da interface gráfica.',
                    output: 'Um novo arquivo de texto (.txt) com os valores recalculados e arredondados.',
                    funcionamento: 'O usuário utiliza uma aplicação de desktop para selecionar um arquivo CONEMB e uma pasta de destino. A aplicação lê o arquivo, identifica as linhas que precisam de ajuste, realiza os cálculos e arredondamentos necessários e salva o resultado no arquivo de destino.',
                    ferramenta: 'Python (com Tkinter).',
                    frequencia: 'Sob demanda',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: 'Processo em fase de migração para o sistema TMS.'
                },
                {
                    nome: 'App Desacordo',
                    finalidade: 'Consultar em massa o status de "Evento em Desacordo" para uma lista de chaves de CT-e, utilizando a API do Arquivei.',
                    sistemas: 'API Arquivei (Web Service), Aplicação de Desktop (GUI), Pastas de rede.',
                    input: 'Lista de chaves de CT-e (uma por linha) inserida pelo usuário numa interface gráfica.',
                    output: 'Arquivo Excel (.xlsx) com duas colunas: a chave do CT-e e a confirmação da existência ("SIM" ou "NÃO") de um evento de desacordo.',
                    funcionamento: 'Através de uma aplicação de desktop, o usuário insere múltiplas chaves de CT-e. A aplicação consome a API do Arquivei para verificar, para cada chave, a existência do evento de desacordo (tipo 610110). O resultado é compilado e salvo numa planilha Excel.',
                    ferramenta: 'Python (com Tkinter, Requests, Pandas).',
                    frequencia: 'Diariamente às 15h00.',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                {
                    nome: 'App DOCCOB',
                    finalidade: 'Separar um arquivo CONEMB em múltiplos arquivos, um para cada tipo de serviço encontrado no documento original.',
                    sistemas: 'Aplicação de Desktop (GUI), Pastas de rede (Sistema de Arquivos).',
                    input: 'Arquivo de texto (.txt) do tipo CONEMB e uma pasta de destino, ambos selecionados pelo usuário na interface gráfica.',
                    output: 'Vários arquivos de texto (.txt), cada um contendo os dados de um tipo de serviço específico, salvos na pasta de destino.',
                    funcionamento: 'O usuário seleciona um arquivo CONEMB de entrada e uma pasta de saída. A aplicação lê o arquivo, identifica o cabeçalho e processa as linhas de dados. Cada linha de serviço é utilizada para criar ou adicionar dados a um arquivo de saída correspondente. No final, é calculado e adicionado um totalizador a cada arquivo gerado.',
                    ferramenta: 'Python (com Tkinter).',
                    frequencia: 'Sob demanda',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                {
                    nome: 'App PIX',
                    finalidade: 'Facilitar a criação de diversos tipos de faturas (PIX, Adiantamentos, RPA, Caixinha) no Oracle Cloud, através de uma aplicação de desktop multifuncional.',
                    sistemas: 'Oracle Cloud (API REST), Aplicação de Desktop (GUI), Servidor de E-mail (SMTP), Pastas de rede.',
                    input: 'Dados inseridos pelo usuário numa interface gráfica (Tkinter), incluindo informações do fornecedor, valores, descrições, ordens de compra, e seleção de arquivos de anexo.',
                    output: 'Criação e validação de faturas no Oracle Cloud e envio de e-mails de notificação com anexos para os intervenientes.',
                    funcionamento: 'Uma aplicação de desktop com múltiplos separadores que permite ao usuário criar diferentes tipos de faturas no Oracle Cloud. O usuário preenche um formulário com os dados do pagamento, anexa documentos e a aplicação se comunica com a API da Oracle para criar, anexar e validar a fatura, notificando por fim os envolvidos por e-mail.',
                    ferramenta: 'Python (com Tkinter, Requests, SMTPLib, python-dotenv).',
                    frequencia: 'Sob demanda',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: 'Processo em fase de migração para o sistema TMS.'
                },
                {
                    nome: 'App Seguros',
                    finalidade: 'Gerenciar e automatizar a comunicação de sinistros, consolidando informações e enviando e-mails padronizados.',
                    sistemas: 'SharePoint, Banco de Dados SQL Server (Newsitex), Servidor de E-mail (SMTP), Aplicação de Desktop (GUI).',
                    input: 'Arquivo Excel ("Sinistros Tragetta - Geral.xlsx") via SharePoint e seleção de sinistros pelo usuário numa interface gráfica.',
                    output: 'E-mails de comunicação de sinistro formatados em HTML, enviados a clientes e equipas internas.',
                    funcionamento: 'A aplicação baixa uma base de dados de sinistros do SharePoint e exibe-a numa interface gráfica, permitindo ao usuário filtrar e selecionar os casos. Com base na seleção e no tipo de comunicação escolhido, a ferramenta gera e envia e-mails padronizados para os contatos registados no TMS, agilizando o processo.',
                    ferramenta: 'Python (com Tkinter, Pandas, Office365-Sharepoint, SMTPLib).',
                    frequencia: 'Sob demanda',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: 'Está sendo desenvolvida uma nova funcionalidade no TMS, sob a responsabilidade de Charles e Thiago Roveri.'
                },
                {
                    nome: 'Envio CTE',
                    finalidade: 'Automatizar o envio de Conhecimentos de Transporte Eletrónicos (CT-e) por e-mail, agrupando os arquivos XML e PDF correspondentes.',
                    sistemas: 'Pastas de rede (Sistema de Arquivos), Servidor de E-mail (SMTP - Office 365).',
                    input: 'Arquivos XML e PDF de CT-es localizados em pastas de rede e uma lista de e-mails de destinatários num arquivo de texto (email.txt).',
                    output: 'E-mails enviados com os arquivos XML e PDF anexados. Os arquivos originais são movidos para uma pasta de "Processados".',
                    funcionamento: 'O robô monitora as pastas de XML e PDF, identifica os pares de arquivos pela chave do CT-e, lê a lista de destinatários de um arquivo de configuração e envia um e-mail para cada CT-e com os respetivos documentos anexados. Após o envio, os arquivos são arquivados.',
                    ferramenta: 'Python (com smtplib, glob, email).',
                    frequencia: 'Sob demanda',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                 {
                    nome: 'IMPORT DEXCO',
                    finalidade: 'Orquestrar o processo de importação de faturas de frete da DEXCO, baixando documentos fiscais e abrindo pedidos de suporte (tickets) no portal do cliente.',
                    sistemas: 'API Arquivei, Portal Jira Service Desk da Duratex (Web), Pastas de rede.',
                    input: 'Planilha Excel (.xlsx) contendo as chaves de acesso dos CT-es e dados para a abertura do pedido de suporte.',
                    output: 'Pedidos de suporte criados no portal Jira da Duratex com os documentos (PDF e XML) anexados e a planilha de controle atualizada.',
                    funcionamento: 'O processo decorre em duas etapas: 1) Um script baixa os PDFs dos CT-es via API da Arquivei. 2) Outro script utiliza o Selenium para acessar ao portal Jira, preencher o formulário de um novo pedido com dados da planilha e anexar os documentos fiscais correspondentes.',
                    ferramenta: 'Python (com Pandas, Requests, Selenium, base64).',
                    frequencia: 'Sob demanda',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                {
                    nome: 'Lançamento de Aluguel',
                    finalidade: 'Automatizar o lançamento de faturas de aluguel no Oracle Cloud, com base numa planilha de controle e nos boletos armazenados no SharePoint.',
                    sistemas: 'SharePoint (via API MS Graph), Oracle Cloud (via API REST), Servidor de E-mail (SMTP).',
                    input: 'Planilha Excel de controle e arquivos de boleto (.pdf) de uma pasta específica no SharePoint.',
                    output: 'Faturas de aluguel criadas no Oracle Cloud, e-mail com relatório de processamento e arquivos processados removidos do SharePoint.',
                    funcionamento: 'O robô baixa a planilha de controle e os boletos de uma pasta no SharePoint. Para cada linha, verifica o histórico para evitar duplicidade, localiza o anexo correspondente e cria a fatura no Oracle Cloud via API. Após o lançamento, envia um e-mail com o relatório e remove os arquivos da pasta do SharePoint.',
                    ferramenta: 'Python (com msal, Pandas, Requests, smtplib, python-dotenv).',
                    frequencia: 'Diariamente às 9h, 12h e 16h.',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                {
                    nome: 'Preparação de Transferências',
                    finalidade: 'Consolidar informações de notas fiscais de transferência para preparar a base de dados para o robô "Lançamento de Transferências", buscando os XMLs no Arquivei e os dados de Remessas no Oracle.',
                    sistemas: 'API Arquivei, Oracle Cloud (via API REST), Pastas de rede.',
                    input: 'Notas fiscais de transferência obtidas via API da Arquivei e a lista de Remessas baixada da API do Oracle Cloud.',
                    output: 'Geração de duas planilhas Excel: uma com a relação de notas fiscais prontas para lançamento e outra com a base de remessas consolidada.',
                    funcionamento: 'O robô executa duas tarefas principais: primeiro, consome a API da Arquivei para obter e validar notas fiscais de transferência. Em seguida, conecta-se à API do Oracle Cloud para baixar a lista de remessas disponíveis. Ambas as informações são salvas em planilhas separadas.',
                    ferramenta: 'Python (com Pandas, Requests, smtplib, python-dotenv).',
                    frequencia: 'Diariamente às 6h.',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: 'Este processo funciona como um pré-requisito, preparando e consolidando os dados que servem de entrada para o RPA "Lançamento de Transferências".'
                },
                {
                    nome: 'Lançamento de Transferências',
                    finalidade: 'Automatizar o lançamento de notas fiscais de transferência no Oracle Cloud.',
                    sistemas: 'Oracle Cloud (Web), Pastas de rede, Servidor de E-mail (SMTP).',
                    input: 'Bases de dados geradas pelo processo "Preparação de Transferências".',
                    output: 'Envio de e-mail com um relatório sobre o status das notas fiscais lançadas no Oracle Cloud.',
                    funcionamento: 'O robô busca as informações de nota por nota através da base de notas fiscais, coleta informações do XML e da base de remessas e, em seguida, realiza o lançamento no Oracle por meio de automação com Selenium.',
                    ferramenta: 'Python (com Pandas, Requests, smtplib, python-dotenv, Selenium).',
                    frequencia: 'Diariamente às 12h e 00h.',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: 'A solução ideal seria uma integração via API, que não foi disponibilizada pela Oracle no FDC.'
                },
                {
                    nome: 'Lote de Pagamentos',
                    finalidade: 'Automatizar a criação de lotes de pagamento no Oracle Cloud a partir de uma planilha de controle, inserindo múltiplas faturas em um único processo.',
                    sistemas: 'Oracle Cloud (Web), Pastas de rede.',
                    input: 'Planilha Excel (.xlsm) com duas abas: uma contendo os dados mestre do lote e outra com a lista de faturas a serem incluídas.',
                    output: 'Criação de um lote de pagamento no Oracle Cloud e atualização da planilha de entrada com o status de cada lançamento.',
                    funcionamento: 'O robô utiliza Selenium para acessar a interface web do Oracle Cloud, criar um novo lote de pagamento com base nos dados da planilha e, em seguida, adicionar individualmente cada fatura listada ao lote. Ao final, o arquivo de controle é movido para uma pasta de processados.',
                    ferramenta: 'Python (com Selenium, Pandas, Openpyxl).',
                    frequencia: 'A cada 10 minutos.',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: 'A automação depende da interface web do Oracle, sendo suscetível a falhas por alterações no layout.'
                },
                {
                    nome: 'ND Juros - Tratar Base',
                    finalidade: 'Baixar e processar a base de faturas do SharePoint para calcular juros e multas por atraso no pagamento, preparando os dados para a geração de Notas de Débito (ND).',
                    sistemas: 'SharePoint (via API MS Graph), Pastas de rede.',
                    input: 'Arquivo "Base.xlsx" de uma pasta específica no SharePoint e o histórico de envios ("Envio_ND.xlsx").',
                    output: 'Planilha "Envio_ND.xlsx" atualizada com os novos encargos calculados e formatados.',
                    funcionamento: 'O robô autentica-se na API do Microsoft Graph, baixa a base de faturas do SharePoint, calcula os dias de atraso, juros e multas, e consolida essas informações com o histórico existente, gerando uma base de dados pronta para a próxima etapa.',
                    ferramenta: 'Python (com Pandas, Requests, msal, Openpyxl).',
                    frequencia: 'Às segundas-feiras, às 8:30.',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: 'Processo depende da consistência e disponibilidade do arquivo "Base.xlsx" no SharePoint.'
                },
                {
                    nome: 'ND Juros - Separação',
                    finalidade: 'Separar a base de dados de encargos em arquivos individuais por cliente, organizando os dados para a criação das Notas de Débito (ND).',
                    sistemas: 'Pastas de rede (Sistema de Arquivos).',
                    input: 'Planilha "Envio_ND.xlsx" contendo todos os encargos a serem cobrados.',
                    output: 'Criação de múltiplas planilhas Excel, uma para cada cliente (CNPJ), e atualização da planilha principal marcando os itens como "SEPARADO".',
                    funcionamento: 'O robô lê a planilha geral de encargos, filtra os itens marcados para envio ("SIM") e agrupa todas as faturas de um mesmo cliente em um único arquivo Excel. Este processo prepara os arquivos que serão utilizados para gerar os PDFs individualizados.',
                    ferramenta: 'Python (com Pandas, Openpyxl).',
                    frequencia: 'Às sextas-feiras, às 6:00.',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                {
                    nome: 'ND Juros - Criação ND',
                    finalidade: 'Gerar as Notas de Débito (ND) em formato PDF a partir dos arquivos de clientes separados, enviá-las por e-mail e registrar o histórico.',
                    sistemas: 'Pastas de rede, Servidor de E-mail (SMTP), API ReceitaWS.',
                    input: 'Planilhas Excel individuais por cliente, geradas pelo robô "Separação".',
                    output: 'Notas de Débito em formato PDF, e-mails enviados aos clientes com as NDs anexadas, e um arquivo de histórico ("Historico_ND.xlsx") atualizado.',
                    funcionamento: 'Para cada cliente, o robô preenche um modelo de Nota de Débito com os dados da planilha correspondente, converte o resultado para PDF, busca informações cadastrais (e-mail) e envia o documento por e-mail. Por fim, atualiza o histórico de envios e limpa os arquivos processados.',
                    ferramenta: 'Python (com Pandas, Openpyxl, Requests, SMTPLib, win32com).',
                    frequencia: 'Às sextas-feiras, às 16:30.',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                 {
                    nome: 'Ordem de Compra',
                    finalidade: 'Consolidar e processar dados de Ordens de Compra (OCs) para aluguéis e combustíveis, a partir de múltiplos arquivos do SharePoint, disponibilizando o resultado para outros processos.',
                    sistemas: 'SharePoint (via API MS Graph), Pastas de rede.',
                    input: 'Múltiplas planilhas Excel ("Lista OC X.xlsx") de uma pasta no SharePoint ("sites/App").',
                    output: 'Duas planilhas Excel consolidadas: uma para Aluguel e outra para Combustível, salvas em pastas de rede distintas.',
                    funcionamento: 'O robô autentica-se na API do Microsoft Graph, baixa as planilhas de OCs de um site de origem, unifica os dados, e depois os separa com base em filtros específicos (códigos de item para aluguel, fornecedores para combustível). Cada base de dados filtrada é salva em seu respectivo diretório para ser consumida por outros robôs.',
                    ferramenta: 'Python (com Pandas, msal, Requests).',
                    frequencia: 'Diariamente a cada 3 horas (00h, 03h, 06h, 09h, 12h, 15h, 18h, 21h).',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                {
                    nome: 'Retirar Hold',
                    finalidade: 'Remover retenções de pagamento (Holds) de faturas no Oracle Cloud e ajustar o método de pagamento.',
                    sistemas: 'Oracle Cloud (via API REST), Pastas de rede.',
                    input: 'Planilha Excel (.xlsx) contendo uma lista de IDs de faturas (INVOICE_ID) que necessitam da remoção da retenção.',
                    output: 'Faturas atualizadas no Oracle Cloud sem a retenção de pagamento e a planilha de controle original movida para uma pasta de processados com o status da operação.',
                    funcionamento: 'O robô lê uma planilha de uma pasta designada, e para cada ID de fatura, realiza uma sequência de chamadas de API no Oracle Cloud para desativar o processamento de documentos de cobrança e remover a flag de retenção da parcela, alterando o método de pagamento para "Eletrônico".',
                    ferramenta: 'Python (com Pandas, Requests).',
                    frequencia: 'Sob demanda',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                {
                    nome: 'RPA CALAMO',
                    finalidade: 'Realizar a conciliação entre duas bases de dados (QUERY NEW e PROTHEUS) para identificar e separar registros de CT-es que não foram localizados na consulta principal.',
                    sistemas: 'Pastas de rede (Sistema de Arquivos).',
                    input: 'Planilha Excel (.xlsx) com duas abas ("QUERY NEW" e "PROTHEUS") contendo dados de faturamento e CT-es.',
                    output: 'Duas planilhas Excel: uma com os registros processados e conciliados ("Processado {data}.xlsx") e outra com os registros que não foram encontrados na base de dados principal ("Não localizados {data}.xlsx").',
                    funcionamento: 'O robô lê os dados das abas "QUERY NEW" e "PROTHEUS" de uma planilha de entrada. Ele cria uma chave única combinando informações de CT-e, data e valor para cruzar os dados. O resultado é a separação dos registros que constam no Protheus mas não na query principal, facilitando a análise de divergências.',
                    ferramenta: 'Python (com Pandas).',
                    frequencia: 'Sob demanda',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                },
                {
                    nome: 'MOA (Mão de Obra Avulsa)',
                    finalidade: 'Automatizar a criação de requisições de compra no Oracle Cloud para pagamentos de Mão de Obra Avulsa (MOA).',
                    sistemas: 'Oracle Cloud (via API REST), Pastas de rede, Servidor de E-mail (SMTP).',
                    input: 'Planilha Excel (.xlsx) contendo os detalhes dos pagamentos de MOA, agrupados por fornecedor, e os respetivos arquivos de anexo.',
                    output: 'Requisições de compra criadas e submetidas no Oracle Cloud, um relatório consolidado em Excel ("Lançadas {data}.xlsx") e um e-mail de notificação com o relatório anexado.',
                    funcionamento: 'O robô processa planilhas de uma pasta específica, agrupando os lançamentos por fornecedor. Para cada grupo, ele valida o fornecedor, cria uma requisição de compra via API no Oracle Cloud, anexa os documentos necessários, submete a requisição para aprovação e, ao final, gera e envia por e-mail um relatório com o status de todos os lançamentos.',
                    ferramenta: 'Python (com Pandas, Requests, SMTPLib, python-dotenv, win32com).',
                    frequencia: 'Diariamente às 12h e 17h.',
                    status: 'Em Produção',
                    setor: 'Financeiro',
                    gaps: ''
                }
            ];

            const botGrid = document.getElementById('bot-grid');
            const modal = document.getElementById('modal');
            const closeModalBtn = document.getElementById('close-modal');
            const setorFilterSelect = document.getElementById('setor-filter');
            let statusChart = null;
            let currentStatusFilter = 'Todos';
            let currentSetorFilter = 'Todos';
            
            const statusClasses = {
                'Em Produção': 'status-producao',
                'Em Testes': 'status-testes',
                'Em Desenvolvimento': 'status-desenvolvimento'
            };

            const statusColors = {
                'Em Produção': '#10B981',
                'Em Testes': '#F59E0B',
                'Em Desenvolvimento': '#3B82F6'
            };
            
            function getStatusTag(status) {
                 return `<span class="status-tag ${statusClasses[status] || ''}">${status}</span>`;
            }

            function renderBotCards(bots) {
                botGrid.innerHTML = '';
                if (bots.length === 0) {
                    botGrid.innerHTML = `<div class="col-span-full text-center py-12 bg-white rounded-2xl shadow-sm">
                        <h3 class="text-xl font-semibold text-gray-600">Nenhum robô encontrado</h3>
                        <p class="text-gray-400 mt-2">Tente alterar os filtros de busca.</p>
                    </div>`;
                    return;
                }
                bots.forEach(bot => {
                    const card = document.createElement('div');
                    card.className = 'bg-white p-6 rounded-2xl shadow-sm hover:shadow-lg hover:-translate-y-1 transition-all duration-300 cursor-pointer';
                    card.innerHTML = `
                        <div class="flex justify-between items-start">
                             <h3 class="text-lg font-bold text-gray-800 mb-2">${bot.nome.replace(/_/g, ' ')}</h3>
                             ${getStatusTag(bot.status)}
                        </div>
                        <p class="text-sm text-gray-500 mb-4 h-10">${bot.finalidade.substring(0, 80)}${bot.finalidade.length > 80 ? '...' : ''}</p>
                        <div class="text-xs text-gray-400 border-t border-gray-100 pt-3">
                            <p><span class="font-semibold">Ferramenta:</span> ${bot.ferramenta}</p>
                            <p class="mt-1"><span class="font-semibold">Setor:</span> ${bot.setor}</p>
                        </div>
                    `;
                    card.addEventListener('click', () => showModal(bot));
                    botGrid.appendChild(card);
                });
            }

            function showModal(bot) {
                document.getElementById('modal-title').textContent = bot.nome.replace(/_/g, ' ');
                document.getElementById('modal-status-container').innerHTML = getStatusTag(bot.status);
                document.getElementById('modal-finalidade').textContent = bot.finalidade;
                document.getElementById('modal-sistemas').textContent = bot.sistemas;
                document.getElementById('modal-input').textContent = bot.input;
                document.getElementById('modal-output').textContent = bot.output;
                document.getElementById('modal-funcionamento').textContent = bot.funcionamento;
                document.getElementById('modal-ferramenta').textContent = bot.ferramenta;
                document.getElementById('modal-frequencia').textContent = bot.frequencia;
                document.getElementById('modal-setor').textContent = bot.setor;
                document.getElementById('modal-gaps').textContent = bot.gaps;

                modal.classList.remove('opacity-0', 'pointer-events-none', 'scale-95');
            }

            function hideModal() {
                modal.classList.add('opacity-0', 'pointer-events-none', 'scale-95');
            }

            function updateDashboardMetrics(bots) {
                const total = bots.length;
                const producao = bots.filter(b => b.status === 'Em Produção').length;
                const testes = bots.filter(b => b.status === 'Em Testes').length;
                const desenvolvimento = bots.filter(b => b.status === 'Em Desenvolvimento').length;
                
                document.getElementById('total-bots').textContent = total;
                document.getElementById('bots-producao').textContent = producao;
                document.getElementById('bots-testes').textContent = testes;
                document.getElementById('bots-desenvolvimento').textContent = desenvolvimento;
                
                updateStatusChart(producao, testes, desenvolvimento);
            }

            function updateStatusChart(producao, testes, desenvolvimento) {
                const ctx = document.getElementById('statusChart').getContext('2d');
                const data = {
                    labels: ['Em Produção', 'Em Testes', 'Em Desenvolvimento'],
                    datasets: [{
                        data: [producao, testes, desenvolvimento],
                        backgroundColor: [statusColors['Em Produção'], statusColors['Em Testes'], statusColors['Em Desenvolvimento']],
                        borderColor: '#f8f7f4',
                        borderWidth: 4,
                        hoverOffset: 8
                    }]
                };

                if (statusChart) {
                    statusChart.data = data;
                    statusChart.update();
                } else {
                    statusChart = new Chart(ctx, {
                        type: 'doughnut',
                        data: data,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            cutout: '70%',
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        boxWidth: 12,
                                        padding: 20,
                                        font: {
                                            family: 'Inter'
                                        }
                                    }
                                },
                                tooltip: {
                                    enabled: true,
                                    titleFont: { family: 'Inter', weight: 'bold' },
                                    bodyFont: { family: 'Inter' },
                                    backgroundColor: '#3d3d3d',
                                    padding: 12,
                                    cornerRadius: 8
                                }
                            }
                        }
                    });
                }
            }
            
            function populateSetorFilter() {
                const setores = ['Todos', ...new Set(botData.map(bot => bot.setor))];
                setorFilterSelect.innerHTML = '';
                setores.forEach(setor => {
                    const option = document.createElement('option');
                    option.value = setor;
                    option.textContent = setor === 'Todos' ? 'Todos os Setores' : setor;
                    setorFilterSelect.appendChild(option);
                });
            }

            function applyFilters() {
                let filteredBots = botData;

                if (currentStatusFilter !== 'Todos') {
                    filteredBots = filteredBots.filter(bot => bot.status === currentStatusFilter);
                }

                if (currentSetorFilter !== 'Todos') {
                    filteredBots = filteredBots.filter(bot => bot.setor === currentSetorFilter);
                }
                
                renderBotCards(filteredBots);
                updateDashboardMetrics(filteredBots);
            }

            function setupFilters() {
                const filterButtons = document.querySelectorAll('.filter-btn-status');
                filterButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        filterButtons.forEach(btn => {
                            btn.classList.remove('bg-blue-600', 'text-white');
                            btn.classList.add('bg-white', 'text-gray-700');
                        });
                        button.classList.add('bg-blue-600', 'text-white');
                        button.classList.remove('bg-white', 'text-gray-700');

                        currentStatusFilter = button.dataset.status;
                        applyFilters();
                    });
                });

                setorFilterSelect.addEventListener('change', (e) => {
                    currentSetorFilter = e.target.value;
                    applyFilters();
                });
            }
            
            function exportToExcel() {
                let filteredBots = botData;

                if (currentStatusFilter !== 'Todos') {
                    filteredBots = filteredBots.filter(bot => bot.status === currentStatusFilter);
                }

                if (currentSetorFilter !== 'Todos') {
                    filteredBots = filteredBots.filter(bot => bot.setor === currentSetorFilter);
                }

                const dataToExport = filteredBots.map(bot => ({
                    'Nome do Robô': bot.nome.replace(/_/g, ' '),
                    'Finalidade': bot.finalidade,
                    'Status': bot.status,
                    'Setor': bot.setor,
                    'Frequência': bot.frequencia,
                    'Ferramentas': bot.ferramenta,
                    'Sistemas Integrados': bot.sistemas,
                    'Input (Entrada)': bot.input,
                    'Output (Saída)': bot.output,
                    'Observações / Gaps': bot.gaps
                }));

                const ws = XLSX.utils.json_to_sheet(dataToExport);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Robôs");
                XLSX.writeFile(wb, "Relatorio_Automacoes_RPA.xlsx");
            }


            closeModalBtn.addEventListener('click', hideModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    hideModal();
                }
            });

            document.getElementById('export-excel-btn').addEventListener('click', exportToExcel);

            renderBotCards(botData);
            updateDashboardMetrics(botData);
            populateSetorFilter();
            setupFilters();
        });
    </script>
</body>
</html>

